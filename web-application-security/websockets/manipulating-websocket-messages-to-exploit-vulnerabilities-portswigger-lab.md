# Manipulating WebSocket Messages to Exploit Vulnerabilities (PortSwigger Lab)

## **Lab: Manipulating WebSocket Messages to Exploit Vulnerabilities**

**Lab URL:** [PortSwigger - Manipulating WebSocket Messages](https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities)

***

### **High-Level Summary**

#### **Objective**

Exploit a **WebSocket message vulnerability** by modifying the message payload to trigger an `alert()` popup in the support agent’s browser.

#### **Key Techniques & Concepts**

* **WebSockets:** A full-duplex, persistent communication channel between a **client and server**.
* **WebSocket Message Manipulation:** Intercepting and modifying WebSocket messages before they reach the server.
* **Client-Side Validation Bypass:** The client applies HTML encoding, but the **server fails to validate** the messages before rendering.

#### **What Makes This Vulnerable?**

* The WebSocket server **trusts client-side encoding** instead of applying its own validation.
* An attacker can **intercept and modify** WebSocket messages, injecting **XSS payloads** that execute when viewed by a support agent.

***

### **PortSwigger Solution Steps**

#### **Step 1: Open a Live Chat Session**

* Click on the **Live Chat** feature and send a test message (`Hello`).
* Observe real-time message transmission, indicating **WebSockets are in use**.

#### **Step 2: Identify WebSocket Traffic in Burp Suite**

* Open **Burp Suite > Proxy > WebSockets History**.
* Observe WebSocket messages being exchanged, including **PING and PONG** frames.

#### **Step 3: Test for Encoding**

*   Send a message containing the **less than (`<`)** character:

    ```
    <test>
    ```
* If the message is displayed as `&lt;test&gt;`, then **client-side encoding is being applied**.

#### **Step 4: Intercept and Modify the WebSocket Message**

* Enable **WebSocket interception** in **Burp Suite**.
*   Send another message containing a **basic XSS payload**:

    ```
    <img src=1 onerror='alert(1)'>
    ```
*   If `<` and `>` are encoded as `&lt;` and `&gt;`, **manually modify the message** in Burp Suite to remove encoding:

    ```
    <img src=1 onerror=alert(1)>
    ```

#### **Step 5: Forward the Modified Message**

* Send the modified message to the server.
* Observe if the `alert(1)` box **executes on both the attacker’s and support agent’s screens**.

✅ **Lab completed successfully**

***

### **Instructor Solution Steps**

#### **Step 1: Engage the Live Chat**

* Open the chat system and send a **basic test message** to confirm WebSockets are in use.

#### **Step 2: Inspect WebSocket Traffic in Burp Suite**

* Open **Burp Suite > Proxy > WebSockets History**.
* Locate messages containing chat messages exchanged between the **client and the server**.

#### **Step 3: Identify Vulnerability by Testing Encoding**

*   Send a **test message** with HTML characters:

    ```
    <script>alert('XSS')</script>
    ```
*   If the response encodes it as:

    ```
    &lt;script&gt;alert('XSS')&lt;/script&gt;
    ```

    Then **client-side encoding** is in place, but **server-side validation is missing**.

#### **Step 4: Modify WebSocket Payload**

* Enable **WebSocket interception** in **Burp Suite**.
*   Modify the intercepted WebSocket message to include the **XSS payload** without encoding:

    ```
    <img src=1 onerror=alert(1)>
    ```

#### **Step 5: Send the Exploit Payload**

* Forward the modified message to the server.
* If the application is vulnerable, the **support agent's browser will execute the XSS payload**, displaying an `alert(1)`.

✅ **Lab completed successfully**

***

### **Explanation of Payloads and Techniques**

#### **WebSockets Overview**

* **WebSockets** enable persistent, bidirectional communication between a **browser and a server**.
* Unlike HTTP requests, WebSockets remain open **until explicitly closed**, allowing continuous data exchange.

#### **Why the Attack Works**

1. **Client-Side Encoding Bypass:**
   * The application **only encodes messages in the client** before sending them over WebSockets.
   * The server **renders messages without validating them**, allowing XSS execution.
2. **WebSocket Interception:**
   * Since **WebSockets do not use standard HTTP headers**, traditional security mechanisms like CSRF protections **do not apply**.
   * **Interception and modification** allow attackers to inject malicious payloads.

#### **Key Indicators of Vulnerability**

* **WebSockets are used without proper server-side validation.**
* **Client-side encoding is applied, but the server does not validate user input.**
* **Intercepting and modifying WebSocket messages results in an XSS execution.**

***

### **Real-World WebSocket Vulnerabilities**

#### **1. Slack WebSocket Security Issue**

* A vulnerability in Slack’s WebSocket-based API allowed attackers to **hijack sessions and send unauthorized messages**.
* Reference: [Slack WebSocket Security Incident](https://www.hackerone.com/blog/slack-hackerone-security-bounty-program)

#### **2. Cryptocurrency Exchange WebSocket Hijacking**

* A security researcher demonstrated how **poor WebSocket authentication** on a crypto exchange allowed unauthorized trades.
* Reference: [WebSocket Authentication Vulnerability in Crypto Trading Platform](https://portswigger.net/daily-swig/how-broken-websockets-authentication-can-lead-to-security-nightmares)

#### **3. Uber WebSocket Exploit**

* Uber’s **real-time notification system** exposed a WebSocket API that attackers could use to **track users’ rides**.
* Reference: [Uber WebSocket Security Report](https://www.zdnet.com/article/uber-fixes-websocket-security-flaw-that-exposed-user-trips/)

***

### **How to Prevent WebSocket-Based Vulnerabilities**

#### **1. Implement Proper Server-Side Validation**

* Always **validate and sanitize user input** on the **server-side**, not just the client.

```javascript
function validateInput(input) {
    return input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

ws.on("message", (msg) => {
    const safeMessage = validateInput(msg);
    sendToClient(safeMessage);
});
```

#### **2. Enforce Content Security Policy (CSP)**

* A properly configured **CSP header** prevents inline JavaScript execution.

```http
Content-Security-Policy: script-src 'self';
```

#### **3. Use WebSocket Authentication Tokens**

* Do not rely on cookies for WebSocket authentication. Instead, use **secure tokens**.

```javascript
const socket = new WebSocket("wss://example.com/socket?token=SECURE_TOKEN");
```

#### **4. Implement Origin and Referrer Checks**

* Restrict WebSocket connections to **trusted domains** using origin checks.

```javascript
ws.on("connection", (socket, req) => {
    if (req.headers.origin !== "https://trustedwebsite.com") {
        socket.terminate();
    }
});
```

***

### **Penetration Testing Checklist for WebSockets**

* [ ] **Inspect WebSocket Messages:** Check for **sensitive data leakage** or user-controlled input.
* [ ] **Test Encoding and Sanitization:** Identify whether **HTML encoding is only applied on the client**.
* [ ] **Check for Authentication Bypass:** Verify if WebSockets rely on **cookie-based authentication** without CSRF protection.
* [ ] **Intercept and Modify Messages:** Use **Burp Suite** to manually tamper with WebSocket frames.

***

### **Final Takeaways**

* **WebSockets provide real-time communication but introduce security risks if not properly validated.**
* **Client-side encoding is insufficient—input must be validated on the server.**
* **Using secure authentication, input validation, and CSP policies significantly reduces WebSocket attack risks.**
